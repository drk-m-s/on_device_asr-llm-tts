<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>LiveBot Demo</title>
</head>
<body>
  <h1>LiveBot Demo</h1>
  <p>User speech and bot responses:</p>
  <pre id="userDisplay"></pre>
  <pre id="botDisplay"></pre>

  <script>
  const ws = new WebSocket('ws://localhost:8765/ws');
  let audioContext;
  let processor;
  let src;
  let sending = false;
  let playing = false;
  const VOICE_THRESHOLD = 0.02;

  const userDisplay = document.getElementById('userDisplay');
  const botDisplay = document.getElementById('botDisplay');

  ws.onopen = () => console.log('Connected');

  ws.onmessage = async (ev) => {
    const msg = JSON.parse(ev.data);

    if(msg.type==="user"){
        userDisplay.textContent += msg.text + "\n";
    } else if(msg.type==="partial"){
        botDisplay.textContent += msg.text;
    } else if(msg.type==="final"){
        botDisplay.textContent += msg.text + "\n";
    } else if(msg.type==="tts"){
        playing = true;
        stopSendingMic();
        const wav_b64 = msg.wav_b64;
        const audioData = base64ToArrayBuffer(wav_b64);
        audioContext = audioContext || new AudioContext({sampleRate:16000});
        const decoded = await audioContext.decodeAudioData(audioData);
        const srcNode = audioContext.createBufferSource();
        srcNode.buffer = decoded;
        srcNode.connect(audioContext.destination);
        srcNode.onended = () => { playing = false; startSendingMic(); };
        srcNode.start();
    }
  };

  function base64ToArrayBuffer(b64){
    const binary_string = atob(b64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for(let i=0;i<len;i++) bytes[i]=binary_string.charCodeAt(i);
    return bytes.buffer;
  }

  async function startSendingMic(){
    if(sending) return;
    sending=true;
    const stream = await navigator.mediaDevices.getUserMedia({audio:true,video:false});
    audioContext = audioContext || new AudioContext({sampleRate:16000});
    src = audioContext.createMediaStreamSource(stream);
    processor = audioContext.createScriptProcessor(4096,1,1);
    src.connect(processor);
    processor.connect(audioContext.destination);
    processor.onaudioprocess = (e)=>{
        const floatBuf = e.inputBuffer.getChannelData(0);
        if(playing && detectSpeech(floatBuf)) ws.send(JSON.stringify({type:'stop_tts'}));
        const resampled = downsampleBuffer(floatBuf,audioContext.sampleRate,16000);
        const pcm16 = floatTo16BitPCM(resampled);
        const b64 = arrayBufferToBase64(pcm16.buffer);
        ws.send(JSON.stringify({type:'audio',pcm_b64:b64}));
    };
  }

  function stopSendingMic(){ sending=false; if(processor){processor.disconnect();processor.onaudioprocess=null;processor=null;} if(src){src.disconnect();src=null;} }
  function detectSpeech(buffer){ let sum=0; for(let i=0;i<buffer.length;i++) sum+=buffer[i]*buffer[i]; let rms=Math.sqrt(sum/buffer.length); return rms>VOICE_THRESHOLD; }
  function downsampleBuffer(buffer,sr,outSR){ if(sr===outSR) return buffer; const ratio=sr/outSR; const newL=Math.round(buffer.length/ratio); const r=new Float32Array(newL); let offR=0,offB=0; while(offR<r.length){ const nextB=Math.round((offR+1)*ratio); let a=0,c=0; for(let i=offB;i<nextB&&i<buffer.length;i++){a+=buffer[i];c++;} r[offR]=a/Math.max(c,1); offR++; offB=nextB;} return r;}
  function floatTo16BitPCM(f){ const l=f.length,b=new ArrayBuffer(l*2),v=new DataView(b); let o=0; for(let i=0;i<l;i++,o+=2){let s=Math.max(-1,Math.min(1,f[i])); v.setInt16(o,s<0?s*0x8000:s*0x7FFF,true);} return new Uint8Array(b);}
  function arrayBufferToBase64(b){ let s=''; const a=new Uint8Array(b); for(let i=0;i<a.byteLength;i++) s+=String.fromCharCode(a[i]); return btoa(s);}
  startSendingMic();
  </script>
</body>
</html>
